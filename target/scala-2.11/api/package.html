<!DOCTYPE html >
<html>
        <head>
          <title>root - _root_</title>
          <meta name="description" content="root - root " />
          <meta name="keywords" content="root root " />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="lib/jquery.js" id="jquery-js"></script>
      <script type="text/javascript" src="lib/jquery-ui.js"></script>
      <script type="text/javascript" src="lib/template.js"></script>
      <script type="text/javascript" src="lib/tools.tooltip.js"></script>
      
      <script type="text/javascript">
         if(top === self) {
            var url = 'index.html';
            var hash = 'package';
            var anchor = window.location.hash;
            var anchor_opt = '';
            if (anchor.length >= 1)
              anchor_opt = '@' + anchor.substring(1);
            window.location.href = url + '#' + hash + anchor_opt;
         }
   	  </script>
    
        </head>
        <body class="value">
      <div id="definition">
        <img src="lib/package_big.png" />
        
        <h1>root package</h1> <span class="permalink">
      <a href="index.html#package" title="Permalink" target="_top">
        <img src="lib/permalink.png" />
      </a>
    </span>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <span class="name">root</span>
      </span>
      </h4>
      
          <div id="comment" class="fullcommenttop"></div>
        

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input id="mbrsel-input" type="text" accesskey="/" /></span><span class="post"></span></div>
        
        
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        

        

        <div id="values" class="values members">
              <h3>Value Members</h3>
              <ol><li name="_root_.infcalcs" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="infcalcs"></a>
      <a id="infcalcs:infcalcs"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a href="infcalcs/package.html"><span class="name">infcalcs</span></a>
      </span>
      </h4><span class="permalink">
      <a href="index.html#package@infcalcs" title="Permalink" target="_top">
        <img src="lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Information theory calculations.</p><div class="fullcomment"><div class="comment cmt"><p>Information theory calculations.</p><p>This package implements calculation of information-theoretic quantities, in
particular estimates of mutual information and channel capacity for
continuous variables.</p><p>For information on building, testing, and using the code, see the README
file.</p><p>The steps in the channel capacity calculation are outlined below. For more
details on the theory underlying the approach taken, see the supplementary
information for Suderman, Bachman et al. (2014).</p><ul><li>In the top-level main function, <a href="infcalcs/EstCC$.html" class="extype" name="infcalcs.EstCC">EstCC</a>, command-line arguments are
   parsed and the data and configuration parameters are loaded.</li><li>Because the channel capacity depends on the input distribution, various
   input weights are generated to determine which input weightings yield the
   highest mutual information between input and output. Input weights are
   generated using the functions <a href="infcalcs/EstimateCC$.html#uniWeight(bounds:infcalcs.TreeDef.Tree,in:List[Double]):List[infcalcs.Weight]" class="extmbr" name="infcalcs.EstimateCC#uniWeight">EstimateCC.uniWeight</a> and
   <a href="infcalcs/EstimateCC$.html#biWeight(bounds:infcalcs.TreeDef.Tree,in:List[Double]):List[infcalcs.Weight]" class="extmbr" name="infcalcs.EstimateCC#biWeight">EstimateCC.biWeight</a>, which allow weighting of the input distribution
   according to unimodal and bimodal Gaussian distributions, respectively.</li><li>Mutual information is calculated for each proposed input weighting
   by the function <a href="infcalcs/EstimateCC$.html#calcWithWeightsMult(weights:List[Option[infcalcs.Weight]],bins:Vector[infcalcs.Pair[infcalcs.NTuple[Int]]],pl:infcalcs.DRData):List[Vector[infcalcs.EstTuple]]" class="extmbr" name="infcalcs.EstimateCC#calcWithWeightsMult">EstimateCC.calcWithWeightsMult</a>.</li><li>For each weighting, the algorithm tries a wide variety of bin
   numbers/sizes to arrive at an estimate that is not biased by the bin size.
   The ranges of input and output bins are specified by configuration
   parameters.</li><li>For each unique combination of input/output bin sizes, the algorithm
   builds the contingency tables for the raw data as well as for randomly
   selected subsamples of the data. These contingency tables are generated
   by <a href="infcalcs/EstimateMI$.html#buildDataMult(binPair:infcalcs.Pair[infcalcs.NTuple[Int]],data:infcalcs.DRData,seed:Int,wts:Option[infcalcs.Weight]):infcalcs.RegDataMult" class="extmbr" name="infcalcs.EstimateMI#buildDataMult">EstimateMI.buildDataMult</a>.</li><li>After calculating the mutual information for each contingency table
   (implemented in <a href="infcalcs/ContTable.html#mutualInformation:Double" class="extmbr" name="infcalcs.ContTable#mutualInformation">ContTable.mutualInformation</a>) the unbiased mutual
   information is estimated by performing a linear regression of the mutual
   information of each subsampled dataset against the inverse sample size;
   the intercept of the linear regression is the unbiased mutual
   information estimate. The regression calculation is performed by
   <a href="infcalcs/EstimateMI$.html#calcMultRegs(r:infcalcs.RegDataMult):(infcalcs.SLR,List[Option[infcalcs.SLR]])" class="extmbr" name="infcalcs.EstimateMI#calcMultRegs">EstimateMI.calcMultRegs</a>.</li><li>Because increasing the number of bins can artifactually inflate estimates
   of MI, identical MI calculations are performed on shuffled datasets of
   varying sizes. The function <a href="infcalcs/EstimateMI$.html#optMIMult(d:Vector[infcalcs.EstTuple]):infcalcs.EstTuple" class="extmbr" name="infcalcs.EstimateMI#optMIMult">EstimateMI.optMIMult</a> then selects the MI
   estimate that maximizes the MI estimate for real data while keeping the
   the MI estimate for randomized data below the cutoff specified in the
   configuration.</li><li><a href="infcalcs/EstimateCC$.html#getResultsMult(est:Vector[Vector[infcalcs.EstTuple]],filePrefix:Option[String]):infcalcs.EstTuple" class="extmbr" name="infcalcs.EstimateCC#getResultsMult">EstimateCC.getResultsMult</a> then reports the channel capacity estimate
   as the maximum mutual information estimate obtained for all of the input
   weightings tested.
</li></ul></div></div>
    </li></ol>
            </div>

        

        
        </div>

        <div id="inheritedMembers">
        
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>


    </body>
      </html>