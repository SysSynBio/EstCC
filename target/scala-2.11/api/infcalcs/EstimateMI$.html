<!DOCTYPE html >
<html>
        <head>
          <title>EstimateMI - infcalcs.EstimateMI</title>
          <meta name="description" content="EstimateMI - infcalcs.EstimateMI" />
          <meta name="keywords" content="EstimateMI infcalcs.EstimateMI" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="../lib/jquery.js" id="jquery-js"></script>
      <script type="text/javascript" src="../lib/jquery-ui.js"></script>
      <script type="text/javascript" src="../lib/template.js"></script>
      <script type="text/javascript" src="../lib/tools.tooltip.js"></script>
      
      <script type="text/javascript">
         if(top === self) {
            var url = '../index.html';
            var hash = 'infcalcs.EstimateMI$';
            var anchor = window.location.hash;
            var anchor_opt = '';
            if (anchor.length >= 1)
              anchor_opt = '@' + anchor.substring(1);
            window.location.href = url + '#' + hash + anchor_opt;
         }
   	  </script>
    
        </head>
        <body class="value">
      <div id="definition">
        <img src="../lib/object_big.png" />
        <p id="owner"><a href="package.html" class="extype" name="infcalcs">infcalcs</a></p>
        <h1>EstimateMI</h1>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <span class="name">EstimateMI</span>
      </span>
      </h4>
      
          <div id="comment" class="fullcommenttop"><div class="comment cmt"><p>Contains methods for estimating mutual information.</p><p>The principal methods used by top-level calling functions are:</p><ul><li><a href="#genEstimatesMult(pl:infcalcs.DRData,binTupList:List[infcalcs.Pair[Int]],wts:Option[infcalcs.Weight]):List[(infcalcs.Pair[Int],List[infcalcs.Pair[Double]])]" class="extmbr" name="infcalcs.EstimateMI#genEstimatesMult">genEstimatesMult</a>, which takes a dataset and a set of bin sizes and
   returns mutual information estimates for each bin size, and</li><li><a href="#optMIMult(d:List[(infcalcs.Pair[Int],List[infcalcs.Pair[Double]])]):(infcalcs.Pair[Int],List[infcalcs.Pair[Double]])" class="extmbr" name="infcalcs.EstimateMI#optMIMult">optMIMult</a>, which takes the mutual information estimates produced by
   <a href="#genEstimatesMult(pl:infcalcs.DRData,binTupList:List[infcalcs.Pair[Int]],wts:Option[infcalcs.Weight]):List[(infcalcs.Pair[Int],List[infcalcs.Pair[Double]])]" class="extmbr" name="infcalcs.EstimateMI#genEstimatesMult">genEstimatesMult</a> and finds the bin size and mutual information that
   maximizes the mutual information for the real but not the randomized
   datasets.</li></ul><p>Other important methods include:</p><ul><li><a href="#buildDataMult(bt:infcalcs.Pair[Int])(pl:infcalcs.DRData,wts:Option[infcalcs.Weight]):infcalcs.RegDataMult" class="extmbr" name="infcalcs.EstimateMI#buildDataMult">buildDataMult</a>, which builds resampled and randomized contingency
   tables</li><li><a href="#calcMultRegs(r:infcalcs.RegDataMult):(infcalcs.SLR,List[Option[infcalcs.SLR]])" class="extmbr" name="infcalcs.EstimateMI#calcMultRegs">calcMultRegs</a>, which estimates the mutual information by linear
   regression.
</li></ul></div><div class="toggleContainer block">
          <span class="toggle">Linear Supertypes</span>
          <div class="superTypes hiddenContent"><span class="extype" name="scala.AnyRef">AnyRef</span>, <span class="extype" name="scala.Any">Any</span></div>
        </div></div>
        

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input id="mbrsel-input" type="text" accesskey="/" /></span><span class="post"></span></div>
        <div id="order">
              <span class="filtertype">Ordering</span>
              <ol>
                
                <li class="alpha in"><span>Alphabetic</span></li>
                <li class="inherit out"><span>By inheritance</span></li>
              </ol>
            </div>
        <div id="ancestors">
                <span class="filtertype">Inherited<br />
                </span>
                <ol id="linearization">
                  <li class="in" name="infcalcs.EstimateMI"><span>EstimateMI</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
                </ol>
              </div><div id="ancestors">
            <span class="filtertype"></span>
            <ol>
              <li class="hideall out"><span>Hide All</span></li>
              <li class="showall in"><span>Show all</span></li>
            </ol>
            <a href="http://docs.scala-lang.org/overviews/scaladoc/usage.html#members" target="_blank">Learn more about member selection</a>
          </div>
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        

        

        <div id="values" class="values members">
              <h3>Value Members</h3>
              <ol><li name="scala.AnyRef#!=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:Any):Boolean"></a>
      <a id="!=(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef###" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="##():Int"></a>
      <a id="##():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $hash$hash" class="name">##</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#==" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:Any):Boolean"></a>
      <a id="==(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.Any#asInstanceOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asInstanceOf[T0]:T0"></a>
      <a id="asInstanceOf[T0]:T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Any.asInstanceOf.T0">T0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="infcalcs.EstimateMI#bDMAlt" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="bDMAlt(bt:infcalcs.Pair[Int])(pl:infcalcs.DRData,wts:Option[infcalcs.Weight]):infcalcs.RegDataMult"></a>
      <a id="bDMAlt(Pair[Int])(DRData,Option[Weight]):RegDataMult"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">bDMAlt</span><span class="params">(<span name="bt">bt: <a href="package.html#Pair[T]=(T,T)" class="extmbr" name="infcalcs.Pair">Pair</a>[<span class="extype" name="scala.Int">Int</span>]</span>)</span><span class="params">(<span name="pl">pl: <a href="package.html#DRData=infcalcs.package.Pair[List[Double]]" class="extmbr" name="infcalcs.DRData">DRData</a></span>, <span name="wts">wts: <span class="extype" name="scala.Option">Option</span>[<a href="package.html#Weight=(List[Double],String)" class="extmbr" name="infcalcs.Weight">Weight</a>] = <span class="symbol">None</span></span>)</span><span class="result">: <a href="package.html#RegDataMult=(List[Double],List[infcalcs.ConstructedTable],List[List[infcalcs.ConstructedTable]],List[String])" class="extmbr" name="infcalcs.RegDataMult">RegDataMult</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Same purpose as <a href="#buildDataMult(bt:infcalcs.Pair[Int])(pl:infcalcs.DRData,wts:Option[infcalcs.Weight]):infcalcs.RegDataMult" class="extmbr" name="infcalcs.EstimateMI#buildDataMult">buildDataMult</a>, but uses <a href="#subSample(frac:Double,t:infcalcs.ContTable,weights:Option[infcalcs.Weight]):infcalcs.ConstructedTable" class="extmbr" name="infcalcs.EstimateMI#subSample">subSample</a> for resampling.</p>
    </li><li name="infcalcs.EstimateMI#buildDataMult" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="buildDataMult(bt:infcalcs.Pair[Int])(pl:infcalcs.DRData,wts:Option[infcalcs.Weight]):infcalcs.RegDataMult"></a>
      <a id="buildDataMult(Pair[Int])(DRData,Option[Weight]):RegDataMult"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">buildDataMult</span><span class="params">(<span name="bt">bt: <a href="package.html#Pair[T]=(T,T)" class="extmbr" name="infcalcs.Pair">Pair</a>[<span class="extype" name="scala.Int">Int</span>]</span>)</span><span class="params">(<span name="pl">pl: <a href="package.html#DRData=infcalcs.package.Pair[List[Double]]" class="extmbr" name="infcalcs.DRData">DRData</a></span>, <span name="wts">wts: <span class="extype" name="scala.Option">Option</span>[<a href="package.html#Weight=(List[Double],String)" class="extmbr" name="infcalcs.Weight">Weight</a>] = <span class="symbol">None</span></span>)</span><span class="result">: <a href="package.html#RegDataMult=(List[Double],List[infcalcs.ConstructedTable],List[List[infcalcs.ConstructedTable]],List[String])" class="extmbr" name="infcalcs.RegDataMult">RegDataMult</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns resampled and randomized contingency tables for estimation of MI.</p><div class="fullcomment"><div class="comment cmt"><p>Returns resampled and randomized contingency tables for estimation of MI.</p><p>The data structure returned by this function contains all of the
information required to calculate the MI for a single pair of bin sizes,
including contingency tables for randomly subsampled datasets (for
unbiased estimation of MI at each bin size) and randomly shuffled
contingency tables (for selection of the appropriate bin size).</p><p>Resampling of the dataset is performed using the <a href="#jackknife(frac:Double,pl:infcalcs.DRData):infcalcs.DRData" class="extmbr" name="infcalcs.EstimateMI#jackknife">jackknife</a> method.</p><p>The return value is a tuple containing:</p><ul><li>a list of the inverse sample sizes for each resampling fraction. This
   list has length (repsPerFraction * number of fractions) + 1. The extra
   entry in the list (the + 1 in the expression) is due to the inclusion
   of the full dataset (with fraction 1.0) in the list of sampling
   fractions.</li><li>a list of contingency tables for subsamples of the data, length as for
   the inverse sample size list.</li><li>a list of lists of randomized contingency tables. Because there are
   numRandTables randomized tables used for every estimate, the outer list
   contains numRandTables entries; each entry consists of
   (repsPerFraction * number of fractions) + 1 randomized contingency
   tables.</li><li>a list of string labels for output and logging purposes, length as for
   the inverse sample size list.
</li></ul></div><dl class="paramcmts block"><dt class="param">bt</dt><dd class="cmt"><p>Pair containing the numbers of row and column bins.</p></dd><dt class="param">pl</dt><dd class="cmt"><p>The input/output dataset.</p></dd><dt class="param">wts</dt><dd class="cmt"><p>An optional weights vector to be applied to the rows.
</p></dd><dt>returns</dt><dd class="cmt"><p>(inverse sample sizes, CTs, randomized CTs, labels)
</p></dd></dl></div>
    </li><li name="infcalcs.EstimateMI#calcMultRegs" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="calcMultRegs(r:infcalcs.RegDataMult):(infcalcs.SLR,List[Option[infcalcs.SLR]])"></a>
      <a id="calcMultRegs(RegDataMult):(SLR,List[Option[SLR]])"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">calcMultRegs</span><span class="params">(<span name="r">r: <a href="package.html#RegDataMult=(List[Double],List[infcalcs.ConstructedTable],List[List[infcalcs.ConstructedTable]],List[String])" class="extmbr" name="infcalcs.RegDataMult">RegDataMult</a></span>)</span><span class="result">: (<a href="SLR.html" class="extype" name="infcalcs.SLR">SLR</a>, <span class="extype" name="scala.List">List</span>[<span class="extype" name="scala.Option">Option</span>[<a href="SLR.html" class="extype" name="infcalcs.SLR">SLR</a>]])</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Calculates regression model for both original and randomized data.</p><div class="fullcomment"><div class="comment cmt"><p>Calculates regression model for both original and randomized data.</p><p>Calculates a linear regression of the mutual information of each
subsampled or randomized dataset vs. the inverse sample size. Returns
results as a tuple: the first entry in the tuple contains the regression
line (as an instance of <a href="SLR.html" class="extype" name="infcalcs.SLR">SLR</a>) for the original dataset; the second
entry in the tuple contains a list of regression lines (<a href="SLR.html" class="extype" name="infcalcs.SLR">SLR</a> objects),
one for each of numRandTables rounds of randomization. The regression
lines for the randomized datasets are obtained by calling <a href="#calcRandRegs(r:infcalcs.RegData):Option[infcalcs.SLR]" class="extmbr" name="infcalcs.EstimateMI#calcRandRegs">calcRandRegs</a>.
Because linear regression may fail on the randomized data, some entries in
the list may be None.
</p></div><dl class="paramcmts block"><dt class="param">r</dt><dd class="cmt"><p>RegDataMult structure, eg as returned by <a href="#buildDataMult(bt:infcalcs.Pair[Int])(pl:infcalcs.DRData,wts:Option[infcalcs.Weight]):infcalcs.RegDataMult" class="extmbr" name="infcalcs.EstimateMI#buildDataMult">buildDataMult</a>.</p></dd><dt>returns</dt><dd class="cmt"><p>(regression on original data, list of regressions on random data)
</p></dd></dl></div>
    </li><li name="infcalcs.EstimateMI#calcRandRegs" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="calcRandRegs(r:infcalcs.RegData):Option[infcalcs.SLR]"></a>
      <a id="calcRandRegs(RegData):Option[SLR]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">calcRandRegs</span><span class="params">(<span name="r">r: <a href="package.html#RegData=(List[Double],List[infcalcs.ConstructedTable],List[infcalcs.ConstructedTable],List[String])" class="extmbr" name="infcalcs.RegData">RegData</a></span>)</span><span class="result">: <span class="extype" name="scala.Option">Option</span>[<a href="SLR.html" class="extype" name="infcalcs.SLR">SLR</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Calculates regression model for randomized data.</p><div class="fullcomment"><div class="comment cmt"><p>Calculates regression model for randomized data.</p><p>Note Option monad present to accommodate failed intercept calculations.
</p></div><dl class="paramcmts block"><dt class="param">r</dt><dd class="cmt"><p>(inverse sample sizes, CTs, randomized CTs, labels)</p></dd><dt>returns</dt><dd class="cmt"><p>Regression line, None if regression failed.
</p></dd></dl></div>
    </li><li name="scala.AnyRef#clone" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clone():Object"></a>
      <a id="clone():AnyRef"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clone</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../java$lang.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.CloneNotSupportedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#eq" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eq(x$1:AnyRef):Boolean"></a>
      <a id="eq(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eq</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#equals" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="equals(x$1:Any):Boolean"></a>
      <a id="equals(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#finalize" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="finalize():Unit"></a>
      <a id="finalize():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">finalize</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../java$lang.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="symbol">classOf[java.lang.Throwable]</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="infcalcs.EstimateMI#genBins" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="genBins(binList:List[Int],otherBinList:List[Int]):List[infcalcs.Pair[Int]]"></a>
      <a id="genBins(List[Int],List[Int]):List[Pair[Int]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">genBins</span><span class="params">(<span name="binList">binList: <span class="extype" name="scala.List">List</span>[<span class="extype" name="scala.Int">Int</span>]</span>, <span name="otherBinList">otherBinList: <span class="extype" name="scala.List">List</span>[<span class="extype" name="scala.Int">Int</span>] = <span class="symbol">List()</span></span>)</span><span class="result">: <span class="extype" name="scala.List">List</span>[<a href="package.html#Pair[T]=(T,T)" class="extmbr" name="infcalcs.Pair">Pair</a>[<span class="extype" name="scala.Int">Int</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Generates all (row, col) bin number tuples.</p><div class="fullcomment"><div class="comment cmt"><p>Generates all (row, col) bin number tuples.</p><p>For example, given (1, 2) and (3, 4) as arguments, returns List((1, 3),
(1, 4), (2, 3), (2, 4)).
</p></div></div>
    </li><li name="infcalcs.EstimateMI#genEstimatesMult" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="genEstimatesMult(pl:infcalcs.DRData,binTupList:List[infcalcs.Pair[Int]],wts:Option[infcalcs.Weight]):List[(infcalcs.Pair[Int],List[infcalcs.Pair[Double]])]"></a>
      <a id="genEstimatesMult(DRData,List[Pair[Int]],Option[Weight]):List[(Pair[Int],List[Pair[Double]])]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">genEstimatesMult</span><span class="params">(<span name="pl">pl: <a href="package.html#DRData=infcalcs.package.Pair[List[Double]]" class="extmbr" name="infcalcs.DRData">DRData</a></span>, <span name="binTupList">binTupList: <span class="extype" name="scala.List">List</span>[<a href="package.html#Pair[T]=(T,T)" class="extmbr" name="infcalcs.Pair">Pair</a>[<span class="extype" name="scala.Int">Int</span>]]</span>, <span name="wts">wts: <span class="extype" name="scala.Option">Option</span>[<a href="package.html#Weight=(List[Double],String)" class="extmbr" name="infcalcs.Weight">Weight</a>] = <span class="symbol">None</span></span>)</span><span class="result">: <span class="extype" name="scala.List">List</span>[(<a href="package.html#Pair[T]=(T,T)" class="extmbr" name="infcalcs.Pair">Pair</a>[<span class="extype" name="scala.Int">Int</span>], <span class="extype" name="scala.List">List</span>[<a href="package.html#Pair[T]=(T,T)" class="extmbr" name="infcalcs.Pair">Pair</a>[<span class="extype" name="scala.Double">Double</span>]])]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Gets mutual information estimates for range of bin sizes by regression.</p><div class="fullcomment"><div class="comment cmt"><p>Gets mutual information estimates for range of bin sizes by regression.</p><p>For each set of bin sizes given, this function:</p><ul><li>builds the randomized and resampled contingency tables by calling
   <a href="#buildDataMult(bt:infcalcs.Pair[Int])(pl:infcalcs.DRData,wts:Option[infcalcs.Weight]):infcalcs.RegDataMult" class="extmbr" name="infcalcs.EstimateMI#buildDataMult">buildDataMult</a></li><li>estimates the unbiased mutual information for the resampled and/or
   randomized datasets by linear regression, by calling <a href="#calcMultRegs(r:infcalcs.RegDataMult):(infcalcs.SLR,List[Option[infcalcs.SLR]])" class="extmbr" name="infcalcs.EstimateMI#calcMultRegs">calcMultRegs</a></li><li>extracts the intercepts and confidence intervals from the regression
   results by calling <a href="#multIntercepts(regs:(infcalcs.SLR,List[Option[infcalcs.SLR]])):List[infcalcs.Pair[Double]]" class="extmbr" name="infcalcs.EstimateMI#multIntercepts">multIntercepts</a>.
</li></ul></div><dl class="paramcmts block"><dt class="param">pl</dt><dd class="cmt"><p>The input/output dataset</p></dd><dt class="param">binTupList</dt><dd class="cmt"><p>Various (nRowBins, nColBins) bin size combinations</p></dd><dt class="param">wts</dt><dd class="cmt"><p>Optional weight vector for inputs</p></dd><dt>returns</dt><dd class="cmt"><p>List of (bin size combo, list of (intercept, conf. int.))
</p></dd></dl></div>
    </li><li name="scala.AnyRef#getClass" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getClass():Class[_]"></a>
      <a id="getClass():Class[_]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getClass</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.Class">Class</span>[_]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#hashCode" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hashCode():Int"></a>
      <a id="hashCode():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hashCode</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.Any#isInstanceOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <a id="isInstanceOf[T0]:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="infcalcs.EstimateMI#isUniform" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isUniform(t:Vector[Vector[Int]]):Boolean"></a>
      <a id="isUniform(Vector[Vector[Int]]):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isUniform</span><span class="params">(<span name="t">t: <span class="extype" name="scala.Vector">Vector</span>[<span class="extype" name="scala.Vector">Vector</span>[<span class="extype" name="scala.Int">Int</span>]]</span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Checks if each row vector in a matrix has the same sum.</p><div class="fullcomment"><div class="comment cmt"><p>Checks if each row vector in a matrix has the same sum.</p><p>Used for testing contingency tables to see if every input (row) value has
the same number of observations associated with it.
</p></div></div>
    </li><li name="infcalcs.EstimateMI#jackknife" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="jackknife(frac:Double,pl:infcalcs.DRData):infcalcs.DRData"></a>
      <a id="jackknife(Double,DRData):DRData"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">jackknife</span><span class="params">(<span name="frac">frac: <span class="extype" name="scala.Double">Double</span></span>, <span name="pl">pl: <a href="package.html#DRData=infcalcs.package.Pair[List[Double]]" class="extmbr" name="infcalcs.DRData">DRData</a></span>)</span><span class="result">: <a href="package.html#DRData=infcalcs.package.Pair[List[Double]]" class="extmbr" name="infcalcs.DRData">DRData</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Resample data by shuffling and then extracting the first frac entries.</p><div class="fullcomment"><div class="comment cmt"><p>Resample data by shuffling and then extracting the first frac entries.</p><p>Note: A likely bottleneck for calculations with large datasets.
</p></div><dl class="paramcmts block"><dt class="param">frac</dt><dd class="cmt"><p>Fraction of the full dataset to take (between 0 and 1).</p></dd><dt class="param">pl</dt><dd class="cmt"><p>The dose/response data.</p></dd><dt>returns</dt><dd class="cmt"><p>Randomly selected fraction of the dataset.
</p></dd></dl></div>
    </li><li name="infcalcs.EstimateMI#makeUniform" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="makeUniform(t:Vector[Vector[Int]]):Vector[Vector[Int]]"></a>
      <a id="makeUniform(Vector[Vector[Int]]):Vector[Vector[Int]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">makeUniform</span><span class="params">(<span name="t">t: <span class="extype" name="scala.Vector">Vector</span>[<span class="extype" name="scala.Vector">Vector</span>[<span class="extype" name="scala.Int">Int</span>]]</span>)</span><span class="result">: <span class="extype" name="scala.Vector">Vector</span>[<span class="extype" name="scala.Vector">Vector</span>[<span class="extype" name="scala.Int">Int</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Re-weights rows in a matrix to have approximately equal sums across rows.</p><div class="fullcomment"><div class="comment cmt"><p>Re-weights rows in a matrix to have approximately equal sums across rows.</p><p>Empty rows with no observations (sums of 0) remain empty after weighting.
</p></div><dl class="paramcmts block"><dt class="param">t</dt><dd class="cmt"><p>A 2D matrix of Ints (e.g., a contingency table)</p></dd><dt>returns</dt><dd class="cmt"><p>A re-weighted matrix.
</p></dd></dl></div>
    </li><li name="infcalcs.EstimateMI#multIntercepts" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="multIntercepts(regs:(infcalcs.SLR,List[Option[infcalcs.SLR]])):List[infcalcs.Pair[Double]]"></a>
      <a id="multIntercepts((SLR,List[Option[SLR]])):List[Pair[Double]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">multIntercepts</span><span class="params">(<span name="regs">regs: (<a href="SLR.html" class="extype" name="infcalcs.SLR">SLR</a>, <span class="extype" name="scala.List">List</span>[<span class="extype" name="scala.Option">Option</span>[<a href="SLR.html" class="extype" name="infcalcs.SLR">SLR</a>]])</span>)</span><span class="result">: <span class="extype" name="scala.List">List</span>[<a href="package.html#Pair[T]=(T,T)" class="extmbr" name="infcalcs.Pair">Pair</a>[<span class="extype" name="scala.Double">Double</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns intercepts and confidence intervals given multiple regression data.</p><div class="fullcomment"><div class="comment cmt"><p>Returns intercepts and confidence intervals given multiple regression data.</p><p>The list of intercepts and intervals returned will be the same length as
the list of regression lines forming the second entry in the tuple
passed as an argument.
</p></div><dl class="paramcmts block"><dt class="param">regs</dt><dd class="cmt"><p>(regression, list of regressions), eg, as from <a href="#calcMultRegs(r:infcalcs.RegDataMult):(infcalcs.SLR,List[Option[infcalcs.SLR]])" class="extmbr" name="infcalcs.EstimateMI#calcMultRegs">calcMultRegs</a></p></dd><dt>returns</dt><dd class="cmt"><p>list of (intercept, intercept 95% conf interval)
</p></dd></dl></div>
    </li><li name="scala.AnyRef#ne" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ne(x$1:AnyRef):Boolean"></a>
      <a id="ne(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ne</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notify" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notify():Unit"></a>
      <a id="notify():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notify</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notifyAll" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notifyAll():Unit"></a>
      <a id="notifyAll():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="infcalcs.EstimateMI#numRandTables" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="numRandTables:Int"></a>
      <a id="numRandTables:Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">numRandTables</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Number of data randomizations to determine bin-based calculation bias.</p>
    </li><li name="infcalcs.EstimateMI#numTablesForCutoff" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="numTablesForCutoff:Int"></a>
      <a id="numTablesForCutoff:Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">numTablesForCutoff</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">The number of randomized tables that must fall below MIRandCutoff to
produce a valid estimate.</p>
    </li><li name="infcalcs.EstimateMI#optMIMult" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="optMIMult(d:List[(infcalcs.Pair[Int],List[infcalcs.Pair[Double]])]):(infcalcs.Pair[Int],List[infcalcs.Pair[Double]])"></a>
      <a id="optMIMult(List[(Pair[Int],List[Pair[Double]])]):(Pair[Int],List[Pair[Double]])"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">optMIMult</span><span class="params">(<span name="d">d: <span class="extype" name="scala.List">List</span>[(<a href="package.html#Pair[T]=(T,T)" class="extmbr" name="infcalcs.Pair">Pair</a>[<span class="extype" name="scala.Int">Int</span>], <span class="extype" name="scala.List">List</span>[<a href="package.html#Pair[T]=(T,T)" class="extmbr" name="infcalcs.Pair">Pair</a>[<span class="extype" name="scala.Double">Double</span>]])]</span>)</span><span class="result">: (<a href="package.html#Pair[T]=(T,T)" class="extmbr" name="infcalcs.Pair">Pair</a>[<span class="extype" name="scala.Int">Int</span>], <span class="extype" name="scala.List">List</span>[<a href="package.html#Pair[T]=(T,T)" class="extmbr" name="infcalcs.Pair">Pair</a>[<span class="extype" name="scala.Double">Double</span>]])</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns the MI estimate that is maximized for real but not randomized data.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the MI estimate that is maximized for real but not randomized data.</p><p>Takes a list of MI estimates for a range of bin sizes, extracted by
linear regression for both real and randomized data (eg, as provided by
<a href="#genEstimatesMult(pl:infcalcs.DRData,binTupList:List[infcalcs.Pair[Int]],wts:Option[infcalcs.Weight]):List[(infcalcs.Pair[Int],List[infcalcs.Pair[Double]])]" class="extmbr" name="infcalcs.EstimateMI#genEstimatesMult">genEstimatesMult</a>) and finds the bin size/MI combination that maximizes
the mutual information while still maintaining the estimated MI of the
randomized data below the cutoff specified by the &quot;cutoffValue&quot;
parameter.
</p></div><dl class="paramcmts block"><dt class="param">d</dt><dd class="cmt"><p>List of (bin size combo, list of (intercept, conf. int.))</p></dd><dt>returns</dt><dd class="cmt"><p>Entry from the list d the optimizes the MI estimate.
</p></dd></dl></div>
    </li><li name="infcalcs.EstimateMI#printCTData" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="printCTData(r:infcalcs.RegData):Unit"></a>
      <a id="printCTData(RegData):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">printCTData</span><span class="params">(<span name="r">r: <a href="package.html#RegData=(List[Double],List[infcalcs.ConstructedTable],List[infcalcs.ConstructedTable],List[String])" class="extmbr" name="infcalcs.RegData">RegData</a></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Prints out all contingency tables for a particular set of regression data.</p><div class="fullcomment"><div class="comment cmt"><p>Prints out all contingency tables for a particular set of regression data.
Useful for debugging purposes.
</p></div></div>
    </li><li name="infcalcs.EstimateMI#subSample" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="subSample(frac:Double,t:infcalcs.ContTable,weights:Option[infcalcs.Weight]):infcalcs.ConstructedTable"></a>
      <a id="subSample(Double,ContTable,Option[Weight]):ConstructedTable"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">subSample</span><span class="params">(<span name="frac">frac: <span class="extype" name="scala.Double">Double</span></span>, <span name="t">t: <a href="ContTable.html" class="extype" name="infcalcs.ContTable">ContTable</a></span>, <span name="weights">weights: <span class="extype" name="scala.Option">Option</span>[<a href="package.html#Weight=(List[Double],String)" class="extmbr" name="infcalcs.Weight">Weight</a>] = <span class="symbol">None</span></span>)</span><span class="result">: <a href="ConstructedTable.html" class="extype" name="infcalcs.ConstructedTable">ConstructedTable</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Resample a fraction of data by modifying the contingency table.</p><div class="fullcomment"><div class="comment cmt"><p>Resample a fraction of data by modifying the contingency table.</p><p>An alternative to the <a href="#jackknife(frac:Double,pl:infcalcs.DRData):infcalcs.DRData" class="extmbr" name="infcalcs.EstimateMI#jackknife">jackknife</a> function.  Resamples the
data by decrementing (nonzero) counts in the contingency table at
randomly chosen indices. After shrinking the number of observations, the
rows are re-weighted to be uniform using <a href="#makeUniform(t:Vector[Vector[Int]]):Vector[Vector[Int]]" class="extmbr" name="infcalcs.EstimateMI#makeUniform">EstimateMI.makeUniform</a>.
Finally, an optional weights vector is applied to the rows.
</p></div><dl class="paramcmts block"><dt class="param">frac</dt><dd class="cmt"><p>Fraction of the observations to keep in the resampled table.</p></dd><dt class="param">t</dt><dd class="cmt"><p>The contingency table to be resampled.</p></dd><dt class="param">weights</dt><dd class="cmt"><p>Weights to be applied to rows after resampling (if any).</p></dd><dt>returns</dt><dd class="cmt"><p>The resampled contingency table.
</p></dd></dl></div>
    </li><li name="scala.AnyRef#synchronized" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="synchronized[T0](x$1:=&gt;T0):T0"></a>
      <a id="synchronized[T0](⇒T0):T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: ⇒ <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>)</span><span class="result">: <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#toString" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toString():String"></a>
      <a id="toString():String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toString</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.String">String</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait():Unit"></a>
      <a id="wait():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long,x$2:Int):Unit"></a>
      <a id="wait(Long,Int):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>, <span name="arg1">arg1: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long):Unit"></a>
      <a id="wait(Long):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li></ol>
            </div>

        

        
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="scala.AnyRef">
              <h3>Inherited from <span class="extype" name="scala.AnyRef">AnyRef</span></h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <span class="extype" name="scala.Any">Any</span></h3>
            </div>
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>


    </body>
      </html>